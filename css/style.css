// =================================================================================
// SIREX - SCRIPT CENTRAL DE PROCESAMIENTO DE NOVEDADES (v1.1 - Corregido)
// Lee un archivo .docx estandarizado, extrae los datos de cada grupo
// y los guarda en sus respectivas colecciones de Firebase.
// =================================================================================

document.addEventListener('DOMContentLoaded', function() {

    // --- CONFIGURACIÓN FIREBASE ---
    const firebaseConfig = {
        apiKey: "AIzaSyDTvriR7KjlAINO44xhDDvIDlc4T_4nilo",
        authDomain: "ucrif-5bb75.firebaseapp.com",
        projectId: "ucrif-5bb75",
        storageBucket: "ucrif-5bb75.appspot.com",
        messagingSenderId: "241698436443",
        appId: "1:241698436443:web:1f333b3ae3f813b755167e"
    };

    if (!firebase.apps.length) {
        firebase.initializeApp(firebaseConfig);
    }
    const db = firebase.firestore();

    // --- ELEMENTOS DOM ---
    const inputDocx = document.getElementById('inputDocx');
    const statusContainer = document.getElementById('status-container');
    const resultsContainer = document.getElementById('results-container');

    // --- MANEJO DE EVENTOS ---
    if (inputDocx) {
        inputDocx.addEventListener('change', handleDocxUpload);
    }

    // =================================================
    // FUNCIONES DE UI (SPINNER Y MENSAJES)
    // =================================================
    function showStatus(message, type = 'info') {
        if (!statusContainer) return;
        let alertClass = 'alert-info';
        if (type === 'success') alertClass = 'alert-success';
        if (type === 'error') alertClass = 'alert-danger';
        statusContainer.innerHTML = `<div class="alert ${alertClass}" role="alert">${message}</div>`;
    }

    function showSpinner(visible) {
        const spinner = document.getElementById('spinner-area');
        if (spinner) {
            spinner.style.display = visible ? 'flex' : 'none';
        }
    }

    function showResults(parsedData) {
        if (!resultsContainer) return;
        resultsContainer.innerHTML = '<h3><i class="bi bi-check-circle-fill text-success"></i> Datos Extraídos</h3>';
        
        for (const key in parsedData) {
            const dataContent = parsedData[key];
            if (dataContent && (Object.keys(dataContent).length > 0 || (Array.isArray(dataContent) && dataContent.length > 0))) {
                const card = document.createElement('div');
                card.className = 'card mb-3 shadow-sm';
                card.innerHTML = `
                    <div class="card-header bg-light"><strong>${key.replace(/_/g, ' ').toUpperCase()}</strong></div>
                    <div class="card-body">
                        <pre class="results-card">${JSON.stringify(dataContent, null, 2)}</pre>
                    </div>
                `;
                resultsContainer.appendChild(card);
            }
        }
    }


    // =================================================
    // LÓGICA PRINCIPAL DE PROCESAMIENTO
    // =================================================
    async function handleDocxUpload(event) {
        const file = event.target.files[0];
        if (!file || !file.name.endsWith('.docx')) {
            showStatus('Por favor, selecciona un archivo .docx válido.', 'error');
            return;
        }

        showSpinner(true);
        resultsContainer.innerHTML = '';
        showStatus('Procesando archivo...', 'info');

        try {
            const arrayBuffer = await file.arrayBuffer();
            const result = await mammoth.convertToHtml({ arrayBuffer });
            const html = result.value;

            // 1. Parsear el HTML para extraer todos los datos
            const parsedData = parseAllSections(html);

            if (Object.keys(parsedData).length <= 2) { // metadata y fecha
                throw new Error("No se pudo extraer ninguna sección de grupo. Revisa que los títulos en el DOCX (ej: 'GRUPO 1') son correctos.");
            }

            showResults(parsedData);

            // 2. Guardar los datos en Firebase
            await saveAllToFirebase(parsedData);
            
            showStatus('¡Proceso completado! Todos los datos han sido guardados en Firebase.', 'success');

        } catch (err) {
            console.error("Error en el procesamiento:", err);
            showStatus(`Error: ${err.message}`, 'error');
        } finally {
            showSpinner(false);
            inputDocx.value = ''; // Reset input
        }
    }
    
    // =================================================
    // PARSERS (El "cerebro" que interpreta el HTML)
    // =================================================

    function findTableAfterTitle(htmlRoot, titleText) {
        const headers = Array.from(htmlRoot.querySelectorAll('h1, h2, h3, h4, p, strong'));
        const targetHeader = headers.find(h => h.textContent.trim().toUpperCase().includes(titleText.toUpperCase()));
        
        if (targetHeader) {
            let nextElement = targetHeader.closest('p, h1, h2, h3, h4')?.nextElementSibling || targetHeader.nextElementSibling;
            while(nextElement) {
                if (nextElement.tagName === 'TABLE') {
                    return nextElement;
                }
                nextElement = nextElement.nextElementSibling;
            }
        }
        console.warn(`No se encontró la tabla para la sección: ${titleText}`);
        return null;
    }

    function mapKeyValueTable(table, keyColumn = 0, valueColumn = 1) {
        const data = {};
        const rows = table.querySelectorAll('tr');
        rows.forEach(row => {
            const cells = row.querySelectorAll('td');
            if (cells.length > valueColumn) {
                const key = cells[keyColumn].textContent.trim();
                const value = cells[valueColumn].textContent.trim();
                if (key) {
                    data[key] = !isNaN(parseFloat(value)) && isFinite(value) && value !== '' ? parseFloat(value) : value;
                }
            }
        });
        return data;
    }

    function mapArrayTable(table) {
        const data = [];
        const headerRow = table.querySelector('tr');
        if (!headerRow) return data;

        const headers = Array.from(headerRow.children)
            .map(th => th.textContent.trim().toLowerCase().replace(/ /g, '_').replace(/\//g, '_').replace(/º/g,'').replace(/\./g, ''));
            
        const rows = Array.from(table.querySelectorAll('tr')).slice(1);
        rows.forEach(row => {
            const cells = row.querySelectorAll('td');
            if (cells.length > 0 && Array.from(cells).some(c => c.textContent.trim() !== '')) {
                const entry = {};
                cells.forEach((cell, index) => {
                    const header = headers[index];
                    if(header) {
                       entry[header] = cell.textContent.trim();
                    }
                });
                data.push(entry);
            }
        });
        return data;
    }

    function parseAllSections(html) {
        const htmlRoot = document.createElement('div');
        htmlRoot.innerHTML = html;

        const data = {};
        
        // --- CORRECCIÓN ---
        // Parseo de Metadata adaptado a tabla y a prueba de undefined
        const metadata = {};
        const firstTable = htmlRoot.querySelector('table');
        if (firstTable && firstTable.textContent.includes('Turno')) {
            const cells = firstTable.querySelectorAll('td');
            // En el DOCX: Turno (celda 0) | Valor (celda 1) | Responsable (celda 2) | Valor (celda 3)
            if (cells.length > 1 && cells[1].textContent.trim()) {
                metadata.turno = cells[1].textContent.trim();
            }
            if (cells.length > 3 && cells[3].textContent.trim()) {
                metadata.responsable = cells[3].textContent.trim();
            }
        }
        data.metadata = metadata; // Se añade el objeto (vacío si no se encuentra nada, pero nunca undefined)

        const tituloTag = Array.from(htmlRoot.querySelectorAll('p')).find(p => p.textContent.startsWith('NOVEDADES B.P.E.F.'));
        if(tituloTag) {
            const match = tituloTag.textContent.match(/\[(.*?)\]/);
            const dateStr = match ? match[1] : new Date().toLocaleDateString('es-ES');
            const dateParts = dateStr.split('/');
            if (dateParts.length === 3) {
                 data.fecha = `${dateParts[2]}-${dateParts[1].padStart(2,'0')}-${dateParts[0].padStart(2,'0')}`;
            }
        }
        if(!data.fecha) {
            const today = new Date();
            data.fecha = today.toISOString().slice(0, 10);
            console.warn("No se encontró fecha en el título, usando fecha actual.");
        }

        const secciones = {
            grupo1: { title: "GRUPO 1", type: 'key-value' },
            investigacion: { title: "GRUPOS 2 y 3", type: 'array' },
            casas_citas: { title: "CONTROL CASA DE CITAS", type: 'array' },
            grupo4: { title: "GRUPO 4", type: 'array' },
            puerto: { title: "PUERTO", type: 'key-value' },
            cecorex: { title: "CECOREX", type: 'key-value', keyCol: 0, valCol: 1 },
            cie: { title: "CIE", type: 'array' },
            gestion: { title: "GESTIÓN", type: 'key-value', keyCol: 0, valCol: 1 }
        };

        for (const [key, config] of Object.entries(secciones)) {
            const table = findTableAfterTitle(htmlRoot, config.title);
            if (table) {
                if (config.type === 'key-value') {
                    data[key] = mapKeyValueTable(table, config.keyCol, config.valCol);
                } else if (config.type === 'array') {
                    data[key] = mapArrayTable(table);
                }
            }
        }
        return data;
    }

    // =================================================
    // LÓGICA DE GUARDADO EN FIREBASE
    // =================================================
    
    async function saveAllToFirebase(data) {
        const fecha = data.fecha;
        if (!fecha) throw new Error("No se pudo determinar la fecha para guardar los registros.");
        
        const fechaSinGuiones = fecha.replace(/-/g, "");
        const batch = db.batch();

        const firebaseMap = {
            cecorex: { collection: "cecorex", id: `cecorex_${fecha}` },
            cie: { collection: "grupo_cie", id: fecha },
            gestion: { collection: "gestion_avanzada", id: `gestion_${fechaSinGuiones}` },
            puerto: { collection: "grupoPuerto_registros", id: `puerto_${fecha}` },
            grupo1: { collection: "grupo1_diario", id: `g1_${fecha}` },
            grupo4: { collection: "grupo4_operativo", id: `g4_${fecha}` },
            investigacion: { collection: "investigacion_diario", id: `inv_${fecha}` },
            casas_citas: { collection: "control_casas_citas", id: `citas_${fecha}` }
        };
        
        for (const [key, fbConfig] of Object.entries(firebaseMap)) {
            if (data[key] && (Object.keys(data[key]).length > 0 || data[key].length > 0)) {
                
                let dataToSave = {
                    fecha: fecha,
                    // --- CORRECCIÓN --- 
                    // Se expande el objeto metadata de forma segura
                    ...(data.metadata.turno && { turno: data.metadata.turno }),
                    ...(data.metadata.responsable && { responsable: data.metadata.responsable }),
                    ...formatDataForFirebase(key, data[key])
                };

                const docRef = db.collection(fbConfig.collection).doc(fbConfig.id);
                batch.set(docRef, dataToSave, { merge: true });
            }
        }
        
        await batch.commit();
    }
    
    function formatDataForFirebase(key, parsedData) {
        switch(key) {
            case 'cie':
                 return { novedades: parsedData };
            case 'investigacion':
                 return { operaciones: parsedData };
            case 'grupo4':
                 return { partes: parsedData };
            // El formato key-value es muy versátil y puede que no necesite formateo
            default:
                return { ...parsedData };
        }
    }

});
